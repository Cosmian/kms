---
name: Packaging

on:
  workflow_call:
    inputs:
      toolchain:
        required: true
        type: string
        default: 1.90.0
  workflow_dispatch:
    inputs:
      toolchain:
        description: Rust toolchain to use (e.g., stable, nightly-YYYY-MM-DD)
        required: true
        type: string
        default: 1.90.0

jobs:
  windows-package:
    uses: ./.github/workflows/build_windows.yml
    with:
      toolchain: ${{ inputs.toolchain }}
      archive-name: windows
      debug_or_release: release

  nix-docker-image:
    name: docker-${{ matrix.features }}-${{ matrix.runner }}
    runs-on: ${{ matrix.runner }}
    permissions:
      contents: read
      packages: write
      id-token: write # Required for cosign keyless signing
    strategy:
      fail-fast: false
      matrix:
        features: [fips, non-fips]
        runner: [ubuntu-24.04, ubuntu-24.04-arm]

    steps:
      - name: Derive architecture from runner
        id: arch
        run: |
          set -euo pipefail
          if [[ "${{ matrix.runner }}" == *arm* ]]; then
            echo "arch=arm64" >> "$GITHUB_OUTPUT"
            echo "platform=linux/arm64" >> "$GITHUB_OUTPUT"
            echo "suffix=-arm64" >> "$GITHUB_OUTPUT"
          else
            echo "arch=amd64" >> "$GITHUB_OUTPUT"
            echo "platform=linux/amd64" >> "$GITHUB_OUTPUT"
            echo "suffix=-amd64" >> "$GITHUB_OUTPUT"
          fi

      - name: Nix installation
        uses: cachix/install-nix-action@v31

      - uses: actions/checkout@v4
        with:
          submodules: recursive

      - name: Login to GHCR
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Install Cosign
        uses: sigstore/cosign-installer@v3.7.0

      - name: Extract base Docker metadata
        id: meta
        uses: docker/metadata-action@v4
        with:
          images: |
            ${{ (matrix.features == 'fips' && 'ghcr.io/cosmian/kms-fips' || 'ghcr.io/cosmian/kms') }}
          tags: |
            type=ref,event=branch
            type=ref,event=pr
            type=semver,pattern={{version}}
            type=semver,pattern={{major}}.{{minor}}

      - name: Append arch suffix to tags
        id: arch_tags
        run: |
          set -euo pipefail
          echo "tags_with_arch<<EOF" >> $GITHUB_OUTPUT
          while IFS= read -r t; do
            [ -n "$t" ] && echo "${t}${{ steps.arch.outputs.suffix }}" >> $GITHUB_OUTPUT
          done <<< "${{ steps.meta.outputs.tags }}"
          echo "EOF" >> $GITHUB_OUTPUT

      - name: Build and load Docker image
        id: build
        run: |
          bash .github/scripts/nix.sh --variant ${{ matrix.features }} docker --load --test

      - name: Get image name and digest
        id: image_info
        run: |
          set -euo pipefail
          # Extract the image name and tag from the loaded image
          IMAGE_INFO=$(docker images --format "{{.Repository}}:{{.Tag}} {{.ID}}" | grep "cosmian-kms" | head -n1)
          IMAGE_NAME=$(echo "$IMAGE_INFO" | awk '{print $1}')
          IMAGE_ID=$(echo "$IMAGE_INFO" | awk '{print $2}')
          echo "Original image: $IMAGE_NAME (ID: $IMAGE_ID)"
          echo "image_name=$IMAGE_NAME" >> $GITHUB_OUTPUT
          echo "image_id=$IMAGE_ID" >> $GITHUB_OUTPUT

      - name: Tag and push images
        id: push
        env:
          TAGS: ${{ steps.arch_tags.outputs.tags_with_arch }}
          IMAGE_NAME: ${{ steps.image_info.outputs.image_name }}
        run: |
          set -euo pipefail
          DIGEST=""
          for tag in ${TAGS}; do
            echo "Tagging and pushing: $tag"
            docker tag "$IMAGE_NAME" "$tag"
            docker push "$tag"

            # Get the digest from the first push
            if [ -z "$DIGEST" ]; then
              DIGEST=$(docker inspect --format='{{index .RepoDigests 0}}' "$tag" | cut -d'@' -f2)
              echo "digest=$DIGEST" >> $GITHUB_OUTPUT
            fi
          done

      - name: Sign Docker images with Cosign
        env:
          DIGEST: ${{ steps.push.outputs.digest }}
          TAGS: ${{ steps.arch_tags.outputs.tags_with_arch }}
        run: |
          images=""
          for tag in ${TAGS}; do
            images+="${tag}@${DIGEST} "
          done
          cosign sign --yes ${images}

      - name: Test Docker image
        run: |
          bash .github/scripts/nix.sh --variant ${{ matrix.features }} docker --test

      - name: Select tag for output
        id: pick
        run: |
          first=$(echo "${{ steps.arch_tags.outputs.tags_with_arch }}" | head -n1)
          echo "first_tag=$first" >> $GITHUB_OUTPUT

    outputs:
      arch-tag: ${{ steps.pick.outputs.first_tag }}
      arch: ${{ steps.arch.outputs.arch }}

  nix-docker-manifest:
    name: Docker manifest - ${{ matrix.features }}
    needs: nix-docker-image
    runs-on: ubuntu-24.04
    permissions:
      contents: read
      packages: write
      id-token: write # Required for cosign keyless signing
    strategy:
      fail-fast: false
      matrix:
        features: [fips, non-fips]
    env:
      REGISTRY_IMAGE: ${{ (matrix.features == 'fips' && 'ghcr.io/cosmian/kms-fips' || 'ghcr.io/cosmian/kms') }}
    steps:
      - name: Login to GHCR
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Install Cosign
        uses: sigstore/cosign-installer@v3.7.0

      - name: Set up Buildx
        uses: docker/setup-buildx-action@v3

      - name: Compute tags
        id: meta
        uses: docker/metadata-action@v4
        with:
          images: |
            ${{ env.REGISTRY_IMAGE }}
          tags: |
            type=ref,event=branch
            type=ref,event=pr
            type=semver,pattern={{version}}
            type=semver,pattern={{major}}.{{minor}}

      - name: Create and push manifest list
        id: manifest
        run: |
          set -euo pipefail
          echo "Tags to manifest:"; echo "${{ steps.meta.outputs.tags }}"
          while IFS= read -r tag; do
            [ -z "$tag" ] && continue
            echo "Creating manifest for $tag"
            docker buildx imagetools create \
              --tag "$tag" \
              "${tag}-amd64" \
              "${tag}-arm64"

            # Get the manifest digest
            DIGEST=$(docker buildx imagetools inspect "$tag" --format '{{json .Manifest}}' | jq -r '.digest')
            echo "manifest_digest_${tag##*:}=$DIGEST" >> $GITHUB_OUTPUT

            docker buildx imagetools inspect "$tag"
          done <<< "${{ steps.meta.outputs.tags }}"

      - name: Sign multi-arch manifest with Cosign
        env:
          TAGS: ${{ steps.meta.outputs.tags }}
        run: |
          images=""
          for tag in ${TAGS}; do
            images+="${tag} "
          done
          cosign sign --yes ${images}

  packages:
    name: ${{ matrix.runner }} - ${{ matrix.features }} - ${{ matrix.link }}
    runs-on: ${{ matrix.runner }}
    strategy:
      fail-fast: false
      matrix:
        features: [fips, non-fips]
        link: [static, dynamic]
        runner: [ubuntu-24.04, ubuntu-24.04-arm, macos-15]

    steps:
      - name: Nix installation
        uses: cachix/install-nix-action@v31

      - uses: actions/checkout@v4
        with:
          submodules: recursive

      - name: Set up GPG
        uses: crazy-max/ghaction-import-gpg@v5
        with:
          gpg_private_key: ${{ secrets.GPG_SIGNING_KEY }}
          passphrase: ${{ secrets.GPG_SIGNING_KEY_PASSPHRASE }}

      - name: List keys
        run: gpg -K

      - name: Package
        run: |
          bash .github/scripts/nix.sh --profile release --variant ${{ matrix.features }} --link ${{ matrix.link }} package
        env:
          GPG_SIGNING_KEY: ${{ secrets.GPG_SIGNING_KEY }}
          GPG_SIGNING_KEY_PASSPHRASE: ${{ secrets.GPG_SIGNING_KEY_PASSPHRASE }}

      - name: Upload hash artifact
        uses: actions/upload-artifact@v4
        with:
          name: hash-${{ matrix.runner }}-${{ matrix.features }}-${{ matrix.link }}
          path: result*/bin/server.${{ matrix.features }}*.sha256
          retention-days: 1
          if-no-files-found: error

      - name: Upload package
        uses: actions/upload-artifact@v4
        with:
          name: ${{ matrix.features }}_${{ matrix.link }}_${{ matrix.runner }}-release
          path: result-*-${{ matrix.features }}-${{ matrix.link }}/*
          retention-days: 1
          if-no-files-found: error

  packages-test:
    needs: packages
    name: In Docker ${{ matrix.container }} - ${{ matrix.features }} - ${{ matrix.link }}${{ matrix.runner == 'ubuntu-24.04-arm' && ' - ARM' || ' - AMD64'
      }}
    runs-on: ${{ matrix.runner }}
    container: ${{ matrix.container }}
    strategy:
      fail-fast: false
      matrix:
        container:
          # Ubuntu LTS releases within the last ~10 years
          - ubuntu:25.04
          - ubuntu:24.04
          - ubuntu:22.04
          - ubuntu:20.04
          # Cannot download artifacts using actions/download-artifact@v4 - Glibc v2.28 required
          # - ubuntu:18.04
          # Debian stable releases within the last ~10 years
          - debian:trixie-slim # Debian 13
          - debian:bookworm-slim # Debian 12
          - debian:bullseye-slim # Debian 11
          - debian:buster-slim # Debian 10
          # Cannot download artifacts using actions/download-artifact@v4 - Glibc v2.28 required
          # - debian:stretch-slim # Debian 9
          # Rocky Linux releases
          - rockylinux/rockylinux:10
          - rockylinux/rockylinux:9
          - rockylinux/rockylinux:8
        features: [fips, non-fips]
        link: [static, dynamic]
        runner: [ubuntu-24.04, ubuntu-24.04-arm]

    steps:
      - name: Download package artifacts
        uses: actions/download-artifact@v4
        with:
          name: ${{ matrix.features }}_${{ matrix.link }}_${{ matrix.runner }}-release

      - name: List downloaded artifacts
        if: ${{ matrix.container != 'rockylinux/rockylinux:8' }}
        run: find .

      - name: Install package
        shell: bash
        run: |
          set -ex
          if [ "${{ startsWith(matrix.container, 'rockylinux') }}" = "true" ]; then
            # RPM-based (Rocky Linux)
            rpm -qpl ./result-rpm-${{ matrix.features }}-${{ matrix.link }}/*.rpm
            rpm -i ./result-rpm-${{ matrix.features }}-${{ matrix.link }}/*.rpm --nodeps || true
          else
            # DEB-based (Ubuntu/Debian)
            dpkg --contents ./result-deb-${{ matrix.features }}-${{ matrix.link }}/*.deb
            # Use apt to handle dependencies when installing local .deb files
            dpkg -i ./result-deb-${{ matrix.features }}-${{ matrix.link }}/*.deb || true
          fi

      - name: Enable info flag in config
        shell: bash
        run: |
          set -ex
          if [ -f /etc/cosmian/kms.toml ]; then
            sed -i 's/info = false/info = true/g' /etc/cosmian/kms.toml
          else
            echo "Config file /etc/cosmian/kms.toml not found; skipping info flag enable."
            exit 1
          fi

      - name: Pre-check file
        shell: bash
        run: |
          set -ex
          # Ensure OpenSSL uses packaged config and modules
          export OPENSSL_CONF="/usr/local/cosmian/lib/ssl/openssl.cnf"
          export OPENSSL_MODULES="/usr/local/cosmian/lib/ossl-modules"
          # Determine installed binary path
          BIN="/usr/sbin/cosmian_kms"
          if [ ! -x "$BIN" ]; then
            if [ -f "/usr/bin/cosmian_kms" ]; then
              BIN="/usr/bin/cosmian_kms"
            fi
          fi
          # Show libs and run
          ldd "$BIN"
          chmod +x "$BIN"
          "$BIN" --version
          "$BIN" --info

      - name: Disable info flag in config
        shell: bash
        run: |
          set -ex
          if [ -f /etc/cosmian/kms.toml ]; then
            sed -i 's/info = true/info = false/g' /etc/cosmian/kms.toml
          else
            echo "Config file /etc/cosmian/kms.toml not found; skipping info flag enable."
            exit 1
          fi

      - name: Run executable file
        shell: bash
        run: |
          set -ex
          # Ensure OpenSSL uses packaged config and modules
          export OPENSSL_CONF="/usr/local/cosmian/lib/ssl/openssl.cnf"
          export OPENSSL_MODULES="/usr/local/cosmian/lib/ossl-modules"
          # Determine installed binary path
          BIN="/usr/sbin/cosmian_kms"
          "$BIN" &
          sleep 5

          # Test UI endpoints
          if command -v curl >/dev/null 2>&1; then
            curl -I http://127.0.0.1:9998/ui/index.html
          else
            # Last resort: pure Bash using /dev/tcp
            # Requires bash; sends a HEAD request and checks for 200
            set +e
            {
              exec 3<>/dev/tcp/127.0.0.1/9998
              printf 'HEAD /ui/index.html HTTP/1.1\r\nHost: 127.0.0.1\r\nConnection: close\r\n\r\n' >&3
              read -r status_line <&3
              echo "$status_line"
              echo "$status_line" | grep -qE 'HTTP/.* 2[0-9]{2}\b'
            } ; rc=$?
            exec 3>&- 3<&-
            set -e
            exit $rc
          fi

  systemd-packages-test:
    needs: packages
    name: Use GH runners ${{ matrix.features }} - ${{ matrix.link }}${{ matrix.runner == 'ubuntu-24.04-arm' && ' - ARM' || ' - AMD64' }}
    runs-on: ${{ matrix.runner }}
    strategy:
      fail-fast: false
      matrix:
        features: [fips, non-fips]
        link: [static, dynamic]
        runner: [ubuntu-24.04, ubuntu-24.04-arm]

    steps:
      - name: Download package artifacts
        uses: actions/download-artifact@v4
        with:
          name: ${{ matrix.features }}_${{ matrix.link }}_${{ matrix.runner }}-release

      - name: List downloaded artifacts
        run: find .

      - name: Install package
        shell: bash
        run: |
          set -ex
          # DEB-based (Ubuntu/Debian)
          dpkg --contents ./result-deb-${{ matrix.features }}-${{ matrix.link }}/*.deb
          # Use apt to handle dependencies when installing local .deb files
          sudo dpkg -i ./result-deb-${{ matrix.features }}-${{ matrix.link }}/*.deb || true

      - name: Enable info flag in config
        shell: bash
        run: |
          set -ex
          if [ -f /etc/cosmian/kms.toml ]; then
            sudo sed -i 's/info = false/info = true/g' /etc/cosmian/kms.toml
          else
            echo "Config file /etc/cosmian/kms.toml not found; skipping info flag enable."
            exit 1
          fi

      - name: Pre-check file
        shell: bash
        run: |
          set -ex
          # Ensure OpenSSL uses packaged config and modules
          export OPENSSL_CONF="/usr/local/cosmian/lib/ssl/openssl.cnf"
          export OPENSSL_MODULES="/usr/local/cosmian/lib/ossl-modules"
          # Determine installed binary path
          BIN="/usr/sbin/cosmian_kms"
          if [ ! -x "$BIN" ]; then
            if [ -f "/usr/bin/cosmian_kms" ]; then
              BIN="/usr/bin/cosmian_kms"
            fi
          fi
          # Show libs and run
          sudo ldd "$BIN"
          sudo chmod +x "$BIN"
          sudo -E "$BIN" --version
          sudo -E "$BIN" --info

      - name: Disable info flag in config
        shell: bash
        run: |
          set -ex
          if [ -f /etc/cosmian/kms.toml ]; then
            sudo sed -i 's/info = true/info = false/g' /etc/cosmian/kms.toml
          else
            echo "Config file /etc/cosmian/kms.toml not found; skipping info flag enable."
            exit 1
          fi

      - name: systemctl start cosmian_kms
        shell: bash
        run: |
          set -ex

          sudo systemctl start cosmian_kms
          sleep 5

          # Check systemd service status
          sudo systemctl status cosmian_kms --no-pager
          if ! systemctl is-active --quiet cosmian_kms; then
            echo "ERROR: cosmian_kms service is not active"
            sudo systemctl status cosmian_kms --no-pager
            sudo journalctl -u cosmian_kms --no-pager -n 50
            exit 1
          fi

          # Test UI endpoints
          if command -v curl >/dev/null 2>&1; then
            curl -I http://127.0.0.1:9998/ui/index.html
          else
            # Last resort: pure Bash using /dev/tcp
            # Requires bash; sends a HEAD request and checks for 200
            set +e
            {
              exec 3<>/dev/tcp/127.0.0.1/9998
              printf 'HEAD /ui/index.html HTTP/1.1\r\nHost: 127.0.0.1\r\nConnection: close\r\n\r\n' >&3
              read -r status_line <&3
              echo "$status_line"
              echo "$status_line" | grep -qE 'HTTP/.* 2[0-9]{2}\b'
            } ; rc=$?
            exec 3>&- 3<&-
            set -e
            exit $rc
          fi

  push-artifacts:
    if: github.repository == 'Cosmian/kms' && !startsWith(github.ref_name, 'dependabot/')
    needs:
      - windows-package
      - packages-test
      - nix-docker-manifest
    uses: ./.github/workflows/push-artifacts.yml
    with:
      project-name: kms
      destination: kms
      debug_or_release: release
