use std::{
    collections::HashSet,
    fmt::{self, Formatter},
};

use serde::{
    de::{self, MapAccess, Visitor},
    ser::SerializeStruct,
    Deserialize, Serialize,
};

use super::kmip_types::{LinkType, LinkedObjectIdentifier};
use crate::{
    kmip_0::kmip_types::ErrorReason,
    kmip_1_4::{
        kmip_data_structures::CryptographicParameters,
        kmip_types::{
            AlternativeName, ApplicationSpecificInformation, CertificateType,
            CryptographicAlgorithm, CryptographicDomainParameters, CryptographicUsageMask, Digest,
            DigitalSignatureAlgorithm, KeyFormatType, KeyValueLocationType, Link, Name, ObjectType,
            RandomNumberGenerator, RevocationReason, State, UsageLimits, X509CertificateIdentifier,
        },
    },
    kmip_2_1::kmip_types::VendorAttribute,
    KmipError,
};

pub const VENDOR_ATTR_TAG: &str = "tag";

/// Constant to use to express there are no tags
pub const EMPTY_TAGS: [&str; 0] = [];

/// The vendor ID to use for Cosmian specific attributes
pub const VENDOR_ID_COSMIAN: &str = "cosmian";

/// The vendor attribute name to use for x.509 extensions
pub const VENDOR_ATTR_X509_EXTENSION: &str = "x509-extension";

pub const VENDOR_ATTR_AAD: &str = "aad";

/// Attributes structure containing all KMIP 1.4 attributes (51 total)
/// as specified in Chapter 3, paragraphs 3.1 to 3.51
#[derive(Serialize, Deserialize, Clone, Debug, Eq, PartialEq, Default)]
#[serde(rename_all = "PascalCase")]
pub struct Attributes {
    /// The Unique Identifier is generated by the server to uniquely identify a
    /// Managed Object.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub unique_identifier: Option<String>,

    /// The Name attribute is a text string used to identify a Managed Object.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub name: Option<Vec<Name>>,

    /// The Object Type attribute describes the type of Managed Object.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub object_type: Option<ObjectType>,

    /// The Cryptographic Algorithm attribute specifies the algorithm to be used
    /// with the Cryptographic Object.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub cryptographic_algorithm: Option<CryptographicAlgorithm>,

    /// The Cryptographic Length attribute specifies the length in bits of the
    /// Cryptographic Object.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub cryptographic_length: Option<i32>,

    /// The Cryptographic Parameters attribute is a structure that contains
    /// various cryptographic parameters to be used with the Cryptographic Object.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub cryptographic_parameters: Option<CryptographicParameters>,

    /// The Cryptographic Domain Parameters attribute is a structure that contains
    /// various cryptographic domain parameters to be used with the Cryptographic Object.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub cryptographic_domain_parameters: Option<CryptographicDomainParameters>,

    /// The Certificate Type attribute is a type of certificate (e.g., X.509).
    #[serde(skip_serializing_if = "Option::is_none")]
    pub certificate_type: Option<CertificateType>,

    /// The Certificate Length attribute specifies the length in bits of the certificate.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub certificate_length: Option<i32>,

    /// The X.509 Certificate Identifier attribute specifies the X.509 certificate identifier.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub x_509_certificate_identifier: Option<X509CertificateIdentifier>,

    /// The X.509 Certificate Subject attribute specifies the subject of the X.509 certificate.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub x_509_certificate_subject: Option<String>,

    /// The X.509 Certificate Issuer attribute specifies the issuer of the X.509 certificate.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub x_509_certificate_issuer: Option<String>,

    /// The Certificate Identifier attribute specifies the identifier of the certificate.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub certificate_identifier: Option<String>,

    /// The Certificate Subject attribute specifies the subject of the certificate.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub certificate_subject: Option<String>,

    /// The Certificate Issuer attribute specifies the issuer of the certificate.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub certificate_issuer: Option<String>,

    /// The Digital Signature Algorithm attribute specifies the algorithm used
    /// to generate the digital signature.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub digital_signature_algorithm: Option<DigitalSignatureAlgorithm>,

    /// The Digest attribute specifies the digest value computed for the object.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub digest: Option<Digest>,

    /// The Operation Policy Name attribute specifies the operation policy for the object.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub operation_policy_name: Option<String>,

    /// The Cryptographic Usage Mask attribute specifies the cryptographic operations
    /// that may be performed using the key.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub cryptographic_usage_mask: Option<CryptographicUsageMask>,

    /// The Lease Time attribute specifies the time period during which the client
    /// expects to maintain its interest in the object.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub lease_time: Option<i64>,

    /// The Usage Limits attribute specifies limitations on usage of the object.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub usage_limits: Option<UsageLimits>,

    /// The State attribute specifies the state of the object.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub state: Option<State>,

    /// The Initial Date attribute specifies when the object was initially created.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub initial_date: Option<i64>,

    /// The Activation Date attribute specifies when the object becomes active.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub activation_date: Option<i64>,

    /// The Process Start Date attribute specifies the start date for a cryptographic process.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub process_start_date: Option<i64>,

    /// The Protect Stop Date attribute specifies the stop date for a cryptographic process.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub protect_stop_date: Option<i64>,

    /// The Deactivation Date attribute specifies when the object becomes inactive.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub deactivation_date: Option<i64>,

    /// The Destroy Date attribute specifies when the object was destroyed.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub destroy_date: Option<i64>,

    /// The Compromise Occurrence Date attribute specifies when a compromise of
    /// the object was detected.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub compromise_occurrence_date: Option<i64>,

    /// The Compromise Date attribute specifies when a compromise of the object
    /// might have occurred.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub compromise_date: Option<i64>,

    /// The Revocation Reason attribute specifies the reason for revocation of the object.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub revocation_reason: Option<RevocationReason>,

    /// The Archive Date attribute specifies when the object was archived.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub archive_date: Option<i64>,

    /// The Object Group attribute specifies the object group to which the object belongs.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub object_group: Option<String>,

    /// The Fresh attribute specifies whether the object is fresh or not.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub fresh: Option<bool>,

    /// The Link attribute specifies links to related objects.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub link: Option<Vec<Link>>,

    /// The Application Specific Information attribute specifies information
    /// specific to the application.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub application_specific_information: Option<ApplicationSpecificInformation>,

    /// The Contact Information attribute specifies contact information for the object.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub contact_information: Option<String>,

    ///A Custom Attribute is a client- or server-defined attribute intended for vendor-specific purposes.
    /// It is created by the client and not interpreted by the server,
    /// or is created by the server and MAY be interpreted by the client.
    /// All custom attributes created by the client SHALL adhere to a naming scheme,
    /// where the name of the attribute SHALL have a prefix of 'x-'.
    /// All custom attributes created by the key management server SHALL adhere to a naming scheme
    /// where the name of the attribute SHALL have a prefix of 'y-'.
    /// The server SHALL NOT accept a client-created or modified attribute,
    /// where the name of the attribute has a prefix of ‘y-‘.
    /// The tag type Custom Attribute is not able to identify the particular attribute;
    /// hence such an attribute SHALL only appear in an Attribute Structure with
    /// its name as defined in Section 2.1.1.
    /// Note: Cosmian implementation: we map it to a 2.1 `VendorAttribute`
    #[serde(skip_serializing_if = "Option::is_none")]
    pub custom_attribute: Option<Vec<CustomAttributeValue>>,

    /// The Key Format Type attribute specifies the format of the key value.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub key_format_type: Option<KeyFormatType>,

    /// The Last Change Date attribute specifies the date and time of the last change.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub last_change_date: Option<i64>,

    /// The Alternative Name attribute specifies alternative names for the object.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub alternative_name: Option<AlternativeName>,

    /// The Key Value Present attribute indicates whether the key value is present
    /// in the object.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub key_value_present: Option<bool>,

    /// The Key Value Location attribute indicates the location of the key value.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub key_value_location: Option<KeyValueLocationType>,

    /// The Original Creation Date attribute specifies the date and time of the
    /// original creation of the object.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub original_creation_date: Option<i64>,

    /// The Random Number Generator attribute specifies the random number generator
    /// used to create the object.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub random_number_generator: Option<RandomNumberGenerator>,

    /// The PKCS#12 Friendly Name attribute specifies the friendly name of the object.
    #[serde(skip_serializing_if = "Option::is_none", rename = "PKCS12FriendlyName")]
    pub pkcs12_friendly_name: Option<String>,

    /// The Description attribute specifies a description of the object.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub description: Option<String>,

    /// The Comment attribute specifies a comment for the object.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub comment: Option<String>,

    /// The Sensitive attribute indicates whether the object is sensitive.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub sensitive: Option<bool>,

    /// The Always Sensitive attribute indicates whether the object has always
    /// been sensitive.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub always_sensitive: Option<bool>,

    /// The Extractable attribute indicates whether the object is extractable.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub extractable: Option<bool>,

    /// The Never Extractable attribute indicates whether the object has ever
    /// been extractable.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub never_extractable: Option<bool>,
}

impl Attributes {
    /// Add a vendor attribute to the list of vendor attributes.
    pub fn add_vendor_attribute(&mut self, vendor_attribute: VendorAttribute) -> &mut Self {
        if let Some(vas) = &mut self.custom_attribute {
            vas.push(CustomAttributeValue::Structure(vendor_attribute));
        } else {
            self.custom_attribute = Some(vec![CustomAttributeValue::Structure(vendor_attribute)]);
        }
        self
    }

    /// Set a vendor attribute to the list of vendor attributes replacing one with an existing value
    /// if any
    pub fn set_vendor_attribute(
        &mut self,
        vendor_identification: &str,
        attribute_name: &str,
        attribute_value: Vec<u8>,
    ) -> &mut Self {
        let va = self.get_vendor_attribute_mut(vendor_identification, attribute_name);
        va.attribute_value = attribute_value;
        self
    }

    /// Return the vendor attribute with the given vendor identification and
    /// attribute name.
    #[must_use]
    pub fn get_vendor_attribute_value(
        &self,
        vendor_identification: &str,
        attribute_name: &str,
    ) -> Option<&[u8]> {
        self.custom_attribute.as_ref().and_then(|vas| {
            vas.iter().find_map(|cav| {
                if let CustomAttributeValue::Structure(va) = cav {
                    if va.vendor_identification == vendor_identification
                        && va.attribute_name == attribute_name
                    {
                        Some(va.attribute_value.as_slice())
                    } else {
                        None
                    }
                } else {
                    None
                }
            })
        })
    }

    /// Return the vendor attribute with the given vendor identification
    /// and remove it from the vendor attributes.
    #[must_use]
    pub fn extract_vendor_attribute_value(
        &mut self,
        vendor_identification: &str,
        attribute_name: &str,
    ) -> Option<Vec<u8>> {
        let value = self
            .get_vendor_attribute_value(vendor_identification, attribute_name)
            .map(<[u8]>::to_vec);
        if value.is_some() {
            self.remove_vendor_attribute(vendor_identification, attribute_name);
        }
        value
    }

    /// Return the vendor attribute with the given vendor identification and
    /// attribute name. If the attribute does not exist, an empty
    /// vendor attribute is created and returned.
    #[must_use]
    #[allow(clippy::indexing_slicing)]
    #[allow(clippy::unreachable)]
    pub fn get_vendor_attribute_mut(
        &mut self,
        vendor_identification: &str,
        attribute_name: &str,
    ) -> &mut VendorAttribute {
        let vas = self.custom_attribute.get_or_insert_with(Vec::new);
        let position = vas.iter().position(|va| {
            if let CustomAttributeValue::Structure(va) = va {
                va.vendor_identification == vendor_identification
                    && va.attribute_name == attribute_name
            } else {
                false
            }
        });
        let len = vas.len();
        let cav = match position {
            None => {
                vas.push(CustomAttributeValue::Structure(VendorAttribute {
                    vendor_identification: vendor_identification.to_owned(),
                    attribute_name: attribute_name.to_owned(),
                    attribute_value: vec![],
                }));
                &mut vas[len]
            }
            Some(position) => &mut vas[position],
        };
        if let CustomAttributeValue::Structure(va) = cav {
            va
        } else {
            unreachable!("CustomAttributeValue has to be a Vendor Attribute")
        }
    }

    /// Remove a vendor attribute from the list of vendor attributes.
    pub fn remove_vendor_attribute(&mut self, vendor_identification: &str, attribute_name: &str) {
        if let Some(vas) = self.custom_attribute.as_mut() {
            vas.retain(|va| {
                if let CustomAttributeValue::Structure(va) = va {
                    va.vendor_identification != vendor_identification
                        || va.attribute_name != attribute_name
                } else {
                    true
                }
            });
            if vas.is_empty() {
                self.custom_attribute = None;
            }
        }
    }

    /// Get the link to the object.
    #[must_use]
    pub fn get_link(&self, link_type: LinkType) -> Option<LinkedObjectIdentifier> {
        self.link.as_ref().and_then(|links| {
            links
                .iter()
                .find(|&l| l.link_type == link_type)
                .map(|l| l.linked_object_identifier.clone())
        })
    }

    /// Remove the link from the attributes
    pub fn remove_link(&mut self, link_type: LinkType) {
        if let Some(links) = self.link.as_mut() {
            links.retain(|l| l.link_type != link_type);
            if links.is_empty() {
                self.link = None;
            }
        }
    }

    /// Get the parent id of the object.
    #[must_use]
    pub fn get_parent_id(&self) -> Option<LinkedObjectIdentifier> {
        self.get_link(LinkType::ParentLink)
    }

    /// Set a link to an object.
    /// If a link of the same type already exists, it is removed.
    /// There can only be one link of a given type.
    pub fn set_link(
        &mut self,
        link_type: LinkType,
        linked_object_identifier: LinkedObjectIdentifier,
    ) {
        self.remove_link(link_type);
        let links = self.link.get_or_insert_with(Vec::new);
        links.push(Link {
            link_type,
            linked_object_identifier,
        });
    }

    /// Set the attributes's object type.
    pub fn set_object_type(&mut self, object_type: ObjectType) {
        self.object_type = Some(object_type);
    }

    /// Set the attributes's `CryptographicUsageMask`.
    pub fn set_cryptographic_usage_mask(&mut self, mask: Option<CryptographicUsageMask>) {
        self.cryptographic_usage_mask = mask;
    }

    /// Set the bits in `mask` to the attributes's `CryptographicUsageMask` bits.
    pub fn set_cryptographic_usage_mask_bits(&mut self, mask: CryptographicUsageMask) {
        let mask = self
            .cryptographic_usage_mask
            .map_or(mask, |attr_mask| attr_mask | mask);

        self.cryptographic_usage_mask = Some(mask);
    }

    /// Check that `flag` bit is set in object's `CryptographicUsageMask`.
    /// If FIPS mode is disabled, check if Unrestricted bit is set too.
    ///
    /// Return `true` if `flag` has at least one bit set in self's attributes,
    /// return `false` otherwise.
    /// Raise error if object's `CryptographicUsageMask` is None.
    pub fn is_usage_authorized_for(&self, flag: CryptographicUsageMask) -> Result<bool, KmipError> {
        let usage_mask = self.cryptographic_usage_mask.ok_or_else(|| {
            KmipError::InvalidKmip21Value(
                ErrorReason::Incompatible_Cryptographic_Usage_Mask,
                "CryptographicUsageMask is None".to_owned(),
            )
        })?;

        #[cfg(not(feature = "fips"))]
        // In non-FIPS mode, Unrestricted can be allowed.
        let flag = flag | CryptographicUsageMask::Unrestricted;

        Ok((usage_mask & flag).bits() != 0)
    }

    /// Remove the authenticated additional data from the attributes and return it - for AESGCM unwrapping
    #[must_use]
    pub fn remove_aad(&mut self) -> Option<Vec<u8>> {
        let aad = self
            .get_vendor_attribute_value(VENDOR_ID_COSMIAN, VENDOR_ATTR_AAD)
            .map(|value: &[u8]| value.to_vec());

        if aad.is_some() {
            self.remove_vendor_attribute(VENDOR_ID_COSMIAN, VENDOR_ATTR_AAD);
        }
        aad
    }

    /// Add the authenticated additional data to the attributes - for AESGCM unwrapping
    pub fn add_aad(&mut self, value: &[u8]) {
        let va = VendorAttribute {
            vendor_identification: VENDOR_ID_COSMIAN.to_owned(),
            attribute_name: VENDOR_ATTR_AAD.to_owned(),
            attribute_value: value.to_vec(),
        };
        self.add_vendor_attribute(va);
    }
}

impl Attributes {
    /// Get the tags from the attributes
    #[must_use]
    pub fn get_tags(&self) -> HashSet<String> {
        self.get_vendor_attribute_value(VENDOR_ID_COSMIAN, VENDOR_ATTR_TAG)
            .map(|value| serde_json::from_slice::<HashSet<String>>(value).unwrap_or_default())
            .unwrap_or_default()
    }

    /// Set the tags on the attributes
    pub fn set_tags<T: IntoIterator<Item = impl AsRef<str>>>(
        &mut self,
        tags: T,
    ) -> Result<(), KmipError> {
        let va = self.get_vendor_attribute_mut(VENDOR_ID_COSMIAN, VENDOR_ATTR_TAG);
        va.attribute_value = serde_json::to_vec::<HashSet<String>>(
            &tags
                .into_iter()
                .map(|t| t.as_ref().to_owned())
                .collect::<HashSet<_>>(),
        )?;
        Ok(())
    }

    /// Check that the user tags are valid i.e. they are not empty and do not start with '_'
    pub fn check_user_tags(tags: &HashSet<String>) -> Result<(), KmipError> {
        for tag in tags {
            if tag.starts_with('_') {
                return Err(KmipError::InvalidTag(
                    "user tags cannot start with _".to_owned(),
                ))
            } else if tag.is_empty() {
                return Err(KmipError::InvalidTag("tags cannot be empty".to_owned()))
            }
        }
        Ok(())
    }

    /// Remove the tags from the attributes and return them
    #[must_use]
    pub fn remove_tags(&mut self) -> Option<HashSet<String>> {
        let tags = self
            .get_vendor_attribute_value(VENDOR_ID_COSMIAN, VENDOR_ATTR_TAG)
            .map(|value| serde_json::from_slice::<HashSet<String>>(value).unwrap_or_default());
        if tags.is_some() {
            self.remove_vendor_attribute(VENDOR_ID_COSMIAN, VENDOR_ATTR_TAG);
        }
        tags
    }
}

impl From<Attributes> for crate::kmip_2_1::kmip_attributes::Attributes {
    fn from(val: Attributes) -> Self {
        Self {
            unique_identifier: val.unique_identifier.map(|unique_identifier| {
                crate::kmip_2_1::kmip_types::UniqueIdentifier::TextString(unique_identifier)
            }),
            name: val.name.map(|n| n.into_iter().map(Into::into).collect()),
            never_extractable: val.never_extractable,
            object_type: val.object_type.map(Into::into),
            cryptographic_algorithm: val.cryptographic_algorithm.map(Into::into),
            cryptographic_length: val.cryptographic_length.map(Into::into),
            cryptographic_parameters: val.cryptographic_parameters.map(Into::into),
            cryptographic_domain_parameters: val.cryptographic_domain_parameters.map(Into::into),
            certificate_type: val.certificate_type.map(Into::into),
            certificate_length: val.certificate_length.map(Into::into),
            x_509_certificate_identifier: val.x_509_certificate_identifier.map(Into::into),
            x_509_certificate_subject: val.x_509_certificate_subject.map(Into::into),
            x_509_certificate_issuer: val.x_509_certificate_issuer.map(Into::into),
            digital_signature_algorithm: val.digital_signature_algorithm.map(Into::into),
            cryptographic_usage_mask: val.cryptographic_usage_mask.map(Into::into),
            lease_time: val.lease_time.map(Into::into),
            usage_limits: val.usage_limits.map(Into::into),
            state: val.state.map(Into::into),
            initial_date: val.initial_date.map(Into::into),
            activation_date: val.activation_date.map(Into::into),
            process_start_date: val.process_start_date.map(Into::into),
            protect_stop_date: val.protect_stop_date.map(Into::into),
            protection_level: None,
            protection_period: None,
            protection_storage_masks: None,
            deactivation_date: val.deactivation_date.map(Into::into),
            destroy_date: val.destroy_date.map(Into::into),
            compromise_occurrence_date: val.compromise_occurrence_date.map(Into::into),
            compromise_date: val.compromise_date.map(Into::into),
            revocation_reason: val.revocation_reason.map(Into::into),
            rotate_date: None,
            rotate_generation: None,
            rotate_interval: None,
            rotate_latest: None,
            rotate_name: None,
            archive_date: val.archive_date.map(Into::into),
            attribute_index: None,
            object_group: val.object_group.map(Into::into),
            fresh: val.fresh.map(Into::into),
            link: val.link.map(|n| n.into_iter().map(Into::into).collect()),
            application_specific_information: val.application_specific_information.map(Into::into),
            contact_information: val.contact_information.map(Into::into),
            last_change_date: val.last_change_date.map(Into::into),
            alternative_name: val.alternative_name.map(Into::into),
            key_value_present: val.key_value_present.map(Into::into),
            key_value_location: val.key_value_location.map(Into::into),
            original_creation_date: val.original_creation_date.map(Into::into),
            random_number_generator: val.random_number_generator.map(Into::into),
            description: val.description.map(Into::into),
            comment: val.comment.map(Into::into),
            sensitive: val.sensitive,
            always_sensitive: val.always_sensitive.map(Into::into),
            certificate_attributes: None,
            critical: None,
            extractable: None,
            key_format_type: None,
            nist_key_type: None,
            object_group_member: None,
            opaque_data_type: None,
            pkcs_12_friendly_name: None,
            quantum_safe: None,
            rotate_offset: None,
            short_unique_identifier: None,
            vendor_attributes: val.custom_attribute.map(|n| {
                n.iter()
                    .filter_map(|cav| {
                        if let CustomAttributeValue::Structure(va) = cav {
                            Some(va.clone())
                        } else {
                            None
                        }
                    })
                    .collect()
            }),
        }
    }
}

impl Attributes {
    #[must_use]
    pub fn to_attributes(&self) -> Vec<Attribute> {
        let mut attributes = Vec::new();
        if let Some(unique_identifier) = &self.unique_identifier {
            attributes.push(Attribute::UniqueIdentifier(unique_identifier.clone()));
        }
        if let Some(name) = &self.name {
            attributes.push(Attribute::Name(name.clone()));
        }
        if let Some(object_type) = &self.object_type {
            attributes.push(Attribute::ObjectType(*object_type));
        }
        if let Some(cryptographic_algorithm) = &self.cryptographic_algorithm {
            attributes.push(Attribute::CryptographicAlgorithm(*cryptographic_algorithm));
        }
        if let Some(cryptographic_length) = &self.cryptographic_length {
            attributes.push(Attribute::CryptographicLength(*cryptographic_length));
        }
        if let Some(cryptographic_parameters) = &self.cryptographic_parameters {
            attributes.push(Attribute::CryptographicParameters(
                cryptographic_parameters.clone(),
            ));
        }
        if let Some(cryptographic_domain_parameters) = &self.cryptographic_domain_parameters {
            attributes.push(Attribute::CryptographicDomainParameters(
                cryptographic_domain_parameters.clone(),
            ));
        }
        if let Some(certificate_type) = &self.certificate_type {
            attributes.push(Attribute::CertificateType(*certificate_type));
        }
        if let Some(certificate_length) = &self.certificate_length {
            attributes.push(Attribute::CertificateLength(*certificate_length));
        }
        if let Some(x_509_certificate_identifier) = &self.x_509_certificate_identifier {
            attributes.push(Attribute::X509CertificateIdentifier(
                x_509_certificate_identifier.clone(),
            ));
        }
        if let Some(x_509_certificate_subject) = &self.x_509_certificate_subject {
            attributes.push(Attribute::X509CertificateSubject(
                x_509_certificate_subject.clone(),
            ));
        }
        if let Some(x_509_certificate_issuer) = &self.x_509_certificate_issuer {
            attributes.push(Attribute::X509CertificateIssuer(
                x_509_certificate_issuer.clone(),
            ));
        }
        if let Some(certificate_identifier) = &self.certificate_identifier {
            attributes.push(Attribute::CertificateIdentifier(
                certificate_identifier.clone(),
            ));
        }
        if let Some(certificate_subject) = &self.certificate_subject {
            attributes.push(Attribute::CertificateSubject(certificate_subject.clone()));
        }
        if let Some(certificate_issuer) = &self.certificate_issuer {
            attributes.push(Attribute::CertificateIssuer(certificate_issuer.clone()));
        }
        if let Some(digital_signature_algorithm) = &self.digital_signature_algorithm {
            attributes.push(Attribute::DigitalSignatureAlgorithm(
                *digital_signature_algorithm,
            ));
        }
        if let Some(digest) = &self.digest {
            attributes.push(Attribute::Digest(digest.clone()));
        }
        if let Some(operation_policy_name) = &self.operation_policy_name {
            attributes.push(Attribute::OperationPolicyName(
                operation_policy_name.clone(),
            ));
        }
        if let Some(cryptographic_usage_mask) = &self.cryptographic_usage_mask {
            attributes.push(Attribute::CryptographicUsageMask(
                cryptographic_usage_mask.to_owned(),
            ));
        }
        if let Some(lease_time) = &self.lease_time {
            attributes.push(Attribute::LeaseTime(*lease_time));
        }
        if let Some(usage_limits) = &self.usage_limits {
            attributes.push(Attribute::UsageLimits(usage_limits.clone()));
        }
        if let Some(state) = &self.state {
            attributes.push(Attribute::State(*state));
        }
        if let Some(initial_date) = &self.initial_date {
            attributes.push(Attribute::InitialDate(*initial_date));
        }
        if let Some(activation_date) = &self.activation_date {
            attributes.push(Attribute::ActivationDate(*activation_date));
        }
        if let Some(process_start_date) = &self.process_start_date {
            attributes.push(Attribute::ProcessStartDate(*process_start_date));
        }
        if let Some(protect_stop_date) = &self.protect_stop_date {
            attributes.push(Attribute::ProtectStopDate(*protect_stop_date));
        }
        if let Some(deactivation_date) = &self.deactivation_date {
            attributes.push(Attribute::DeactivationDate(*deactivation_date));
        }
        if let Some(destroy_date) = &self.destroy_date {
            attributes.push(Attribute::DestroyDate(*destroy_date));
        }
        if let Some(compromise_occurrence_date) = &self.compromise_occurrence_date {
            attributes.push(Attribute::CompromiseOccurrenceDate(
                *compromise_occurrence_date,
            ));
        }
        if let Some(compromise_date) = &self.compromise_date {
            attributes.push(Attribute::CompromiseDate(*compromise_date));
        }
        if let Some(revocation_reason) = &self.revocation_reason {
            attributes.push(Attribute::RevocationReason(revocation_reason.clone()));
        }
        if let Some(archive_date) = &self.archive_date {
            attributes.push(Attribute::ArchiveDate(*archive_date));
        }
        if let Some(object_group) = &self.object_group {
            attributes.push(Attribute::ObjectGroup(object_group.clone()));
        }
        if let Some(fresh) = &self.fresh {
            attributes.push(Attribute::Fresh(*fresh));
        }
        if let Some(link) = &self.link {
            attributes.push(Attribute::Link(link.clone()));
        }
        if let Some(application_specific_information) = &self.application_specific_information {
            attributes.push(Attribute::ApplicationSpecificInformation(
                application_specific_information.clone(),
            ));
        }
        if let Some(contact_information) = &self.contact_information {
            attributes.push(Attribute::ContactInformation(contact_information.clone()));
        }
        if let Some(last_change_date) = &self.last_change_date {
            attributes.push(Attribute::LastChangeDate(*last_change_date));
        }
        if let Some(custom_attribute) = &self.custom_attribute {
            for ca in custom_attribute {
                attributes.push(Attribute::CustomAttribute(ca.clone()));
            }
        }
        if let Some(alternative_name) = &self.alternative_name {
            attributes.push(Attribute::AlternativeName(alternative_name.clone()));
        }
        if let Some(key_value_present) = &self.key_value_present {
            attributes.push(Attribute::KeyValuePresent(*key_value_present));
        }
        if let Some(key_value_location) = &self.key_value_location {
            attributes.push(Attribute::KeyValueLocation(*key_value_location));
        }
        if let Some(original_creation_date) = &self.original_creation_date {
            attributes.push(Attribute::OriginalCreationDate(*original_creation_date));
        }
        if let Some(random_number_generator) = &self.random_number_generator {
            attributes.push(Attribute::RandomNumberGenerator(
                random_number_generator.clone(),
            ));
        }
        if let Some(pkcs12_friendly_name) = &self.pkcs12_friendly_name {
            attributes.push(Attribute::Pkcs12FriendlyName(pkcs12_friendly_name.clone()));
        }
        if let Some(description) = &self.description {
            attributes.push(Attribute::Description(description.clone()));
        }
        if let Some(comment) = &self.comment {
            attributes.push(Attribute::Comment(comment.clone()));
        }
        if let Some(sensitive) = &self.sensitive {
            attributes.push(Attribute::Sensitive(*sensitive));
        }
        if let Some(always_sensitive) = &self.always_sensitive {
            attributes.push(Attribute::AlwaysSensitive(*always_sensitive));
        }
        if let Some(extractable) = &self.extractable {
            attributes.push(Attribute::Extractable(*extractable));
        }
        if let Some(never_extractable) = &self.never_extractable {
            attributes.push(Attribute::NeverExtractable(*never_extractable));
        }
        attributes
    }
}

#[derive(Debug, Clone, PartialEq, Eq)]
pub enum Attribute {
    UniqueIdentifier(String),
    Name(Vec<Name>),
    ObjectType(ObjectType),
    CryptographicAlgorithm(CryptographicAlgorithm),
    CryptographicLength(i32),
    CryptographicParameters(CryptographicParameters),
    CryptographicDomainParameters(CryptographicDomainParameters),
    CertificateType(CertificateType),
    CertificateLength(i32),
    X509CertificateIdentifier(X509CertificateIdentifier),
    X509CertificateSubject(String),
    X509CertificateIssuer(String),
    CertificateIdentifier(String),
    CertificateSubject(String),
    CertificateIssuer(String),
    DigitalSignatureAlgorithm(DigitalSignatureAlgorithm),
    Digest(Digest),
    OperationPolicyName(String),
    CryptographicUsageMask(CryptographicUsageMask),
    LeaseTime(i64),
    UsageLimits(UsageLimits),
    State(State),
    InitialDate(i64),
    ActivationDate(i64),
    ProcessStartDate(i64),
    ProtectStopDate(i64),
    DeactivationDate(i64),
    DestroyDate(i64),
    CompromiseOccurrenceDate(i64),
    CompromiseDate(i64),
    RevocationReason(RevocationReason),
    ArchiveDate(i64),
    ObjectGroup(String),
    Fresh(bool),
    Link(Vec<Link>),
    ApplicationSpecificInformation(ApplicationSpecificInformation),
    ContactInformation(String),
    LastChangeDate(i64),
    CustomAttribute(CustomAttributeValue),
    AlternativeName(AlternativeName),
    KeyValuePresent(bool),
    KeyValueLocation(KeyValueLocationType),
    OriginalCreationDate(i64),
    RandomNumberGenerator(RandomNumberGenerator),
    Pkcs12FriendlyName(String),
    Description(String),
    Comment(String),
    Sensitive(bool),
    AlwaysSensitive(bool),
    Extractable(bool),
    NeverExtractable(bool),
}

impl Serialize for Attribute {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        let mut st = serializer.serialize_struct("Attribute", 2)?;
        match self {
            Self::UniqueIdentifier(value) => {
                st.serialize_field("AttributeName", "Unique Identifier")?;
                st.serialize_field("AttributeValue", value)?;
            }
            Self::Name(value) => {
                st.serialize_field("AttributeName", "Name")?;
                st.serialize_field("AttributeValue", value)?;
            }
            Self::ObjectType(value) => {
                st.serialize_field("AttributeName", "Object Type")?;
                st.serialize_field("AttributeValue", value)?;
            }
            Self::CryptographicAlgorithm(value) => {
                st.serialize_field("AttributeName", "Cryptographic Algorithm")?;
                st.serialize_field("AttributeValue", value)?;
            }
            Self::CryptographicLength(value) => {
                st.serialize_field("AttributeName", "Cryptographic Length")?;
                st.serialize_field("AttributeValue", value)?;
            }
            Self::CryptographicParameters(value) => {
                st.serialize_field("AttributeName", "Cryptographic Parameters")?;
                st.serialize_field("AttributeValue", value)?;
            }
            Self::CryptographicDomainParameters(value) => {
                st.serialize_field("AttributeName", "Cryptographic Domain Parameters")?;
                st.serialize_field("AttributeValue", value)?;
            }
            Self::CertificateType(value) => {
                st.serialize_field("AttributeName", "Certificate Type")?;
                st.serialize_field("AttributeValue", value)?;
            }
            Self::CertificateLength(value) => {
                st.serialize_field("AttributeName", "CertificateLength")?;
                st.serialize_field("AttributeValue", value)?;
            }
            Self::X509CertificateIdentifier(value) => {
                st.serialize_field("AttributeName", "X.509 Certificate Identifier")?;
                st.serialize_field("AttributeValue", value)?;
            }
            Self::X509CertificateSubject(value) => {
                st.serialize_field("AttributeName", "X.509 Certificate Subject")?;
                st.serialize_field("AttributeValue", value)?;
            }
            Self::X509CertificateIssuer(value) => {
                st.serialize_field("AttributeName", "X.509 Certificate Issuer")?;
                st.serialize_field("AttributeValue", value)?;
            }
            Self::CertificateIdentifier(value) => {
                st.serialize_field("AttributeName", "Certificate Identifier")?;
                st.serialize_field("AttributeValue", value)?;
            }
            Self::CertificateSubject(value) => {
                st.serialize_field("AttributeName", "Certificate Subject")?;
                st.serialize_field("AttributeValue", value)?;
            }
            Self::CertificateIssuer(value) => {
                st.serialize_field("AttributeName", "Certificate Issuer")?;
                st.serialize_field("AttributeValue", value)?;
            }
            Self::DigitalSignatureAlgorithm(value) => {
                st.serialize_field("AttributeName", "Digital Signature Algorithm")?;
                st.serialize_field("AttributeValue", value)?;
            }
            Self::Digest(value) => {
                st.serialize_field("AttributeName", "Digest")?;
                st.serialize_field("AttributeValue", value)?;
            }
            Self::OperationPolicyName(value) => {
                st.serialize_field("AttributeName", "Operation Policy Name")?;
                st.serialize_field("AttributeValue", value)?;
            }
            Self::CryptographicUsageMask(value) => {
                st.serialize_field("AttributeName", "Cryptographic Usage Mask")?;
                st.serialize_field("AttributeValue", value)?;
            }
            Self::LeaseTime(value) => {
                st.serialize_field("AttributeName", "Lease Time")?;
                st.serialize_field("AttributeValue", value)?;
            }
            Self::UsageLimits(value) => {
                st.serialize_field("AttributeName", "Usage Limits")?;
                st.serialize_field("AttributeValue", value)?;
            }
            Self::State(value) => {
                st.serialize_field("AttributeName", "State")?;
                st.serialize_field("AttributeValue", value)?;
            }
            Self::InitialDate(value) => {
                st.serialize_field("AttributeName", "Initial Date")?;
                st.serialize_field("AttributeValue", value)?;
            }
            Self::ActivationDate(value) => {
                st.serialize_field("AttributeName", "Activation Date")?;
                st.serialize_field("AttributeValue", value)?;
            }
            Self::ProcessStartDate(value) => {
                st.serialize_field("AttributeName", "Process Start Date")?;
                st.serialize_field("AttributeValue", value)?;
            }
            Self::ProtectStopDate(value) => {
                st.serialize_field("AttributeName", "Protect Stop Date")?;
                st.serialize_field("AttributeValue", value)?;
            }
            Self::DeactivationDate(value) => {
                st.serialize_field("AttributeName", "Deactivation Date")?;
                st.serialize_field("AttributeValue", value)?;
            }
            Self::DestroyDate(value) => {
                st.serialize_field("AttributeName", "Destroy Date")?;
                st.serialize_field("AttributeValue", value)?;
            }
            Self::CompromiseOccurrenceDate(value) => {
                st.serialize_field("AttributeName", "Compromise Occurrence Date")?;
                st.serialize_field("AttributeValue", value)?;
            }
            Self::CompromiseDate(value) => {
                st.serialize_field("AttributeName", "Compromise Date")?;
                st.serialize_field("AttributeValue", value)?;
            }
            Self::RevocationReason(value) => {
                st.serialize_field("AttributeName", "Revocation Reason")?;
                st.serialize_field("AttributeValue", value)?;
            }
            Self::ArchiveDate(value) => {
                st.serialize_field("AttributeName", "Archive Date")?;
                st.serialize_field("AttributeValue", value)?;
            }
            Self::ObjectGroup(value) => {
                st.serialize_field("AttributeName", "Object Group")?;
                st.serialize_field("AttributeValue", value)?;
            }
            Self::Fresh(value) => {
                st.serialize_field("AttributeName", "Fresh")?;
                st.serialize_field("AttributeValue", value)?;
            }
            Self::Link(value) => {
                st.serialize_field("AttributeName", "Link")?;
                st.serialize_field("AttributeValue", value)?;
            }
            Self::ApplicationSpecificInformation(value) => {
                st.serialize_field("AttributeName", "Application Specific Information")?;
                st.serialize_field("AttributeValue", value)?;
            }
            Self::ContactInformation(value) => {
                st.serialize_field("AttributeName", "Contact Information")?;
                st.serialize_field("AttributeValue", value)?;
            }
            Self::LastChangeDate(value) => {
                st.serialize_field("AttributeName", "Last Change Date")?;
                st.serialize_field("AttributeValue", value)?;
            }
            Self::CustomAttribute(value) => {
                st.serialize_field("AttributeName", "Custom Attribute")?;
                st.serialize_field("AttributeValue", value)?;
            }
            Self::AlternativeName(value) => {
                st.serialize_field("AttributeName", "Alternative Name")?;
                st.serialize_field("AttributeValue", value)?;
            }
            Self::KeyValuePresent(value) => {
                st.serialize_field("AttributeName", "Key Value Present")?;
                st.serialize_field("AttributeValue", value)?;
            }
            Self::KeyValueLocation(value) => {
                st.serialize_field("AttributeName", "Key Value Location")?;
                st.serialize_field("AttributeValue", value)?;
            }
            Self::OriginalCreationDate(value) => {
                st.serialize_field("AttributeName", "Original Creation Date")?;
                st.serialize_field("AttributeValue", value)?;
            }
            Self::RandomNumberGenerator(value) => {
                st.serialize_field("AttributeName", "Random Number Generator")?;
                st.serialize_field("AttributeValue", value)?;
            }
            Self::Pkcs12FriendlyName(value) => {
                st.serialize_field("AttributeName", "PKCS#12 Friendly Name")?;
                st.serialize_field("AttributeValue", value)?;
            }
            Self::Description(value) => {
                st.serialize_field("AttributeName", "Description")?;
                st.serialize_field("AttributeValue", value)?;
            }
            Self::Comment(value) => {
                st.serialize_field("AttributeName", "Comment")?;
                st.serialize_field("AttributeValue", value)?;
            }
            Self::Sensitive(value) => {
                st.serialize_field("AttributeName", "Sensitive")?;
                st.serialize_field("AttributeValue", value)?;
            }
            Self::AlwaysSensitive(value) => {
                st.serialize_field("AttributeName", "Always Sensitive")?;
                st.serialize_field("AttributeValue", value)?;
            }
            Self::Extractable(value) => {
                st.serialize_field("AttributeName", "Extractable")?;
                st.serialize_field("AttributeValue", value)?;
            }
            Self::NeverExtractable(value) => {
                st.serialize_field("AttributeName", "Never Extractable")?;
                st.serialize_field("AttributeValue", value)?;
            }
        }
        st.end()
    }
}

impl<'de> Deserialize<'de> for Attribute {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(Deserialize, Debug)]
        #[serde(field_identifier)]
        enum Field {
            AttributeName,
            AttributeValue,
        }

        struct AttributeVisitor;

        impl<'de> Visitor<'de> for AttributeVisitor {
            type Value = Attribute;

            fn expecting(&self, formatter: &mut Formatter) -> fmt::Result {
                formatter.write_str("struct Attribute")
            }

            fn visit_map<V>(self, mut map: V) -> Result<Self::Value, V::Error>
            where
                V: MapAccess<'de>,
            {
                let Some(attribute_name_key) = map.next_key::<String>()? else {
                    return Err(de::Error::custom("missing attribute name in attribute"));
                };
                if attribute_name_key != "AttributeName" {
                    return Err(de::Error::custom(format!(
                        "expected AttributeName in attribute, found {attribute_name_key}"
                    )));
                }
                let attribute_name_value = map.next_value::<String>()?;

                // TODO: Special case of Notify for which there is no attribute value
                // This server cannot handle Notify for now

                let Some(attribute_value_name) = map.next_key::<String>()? else {
                    return Err(de::Error::custom("No attribute value in attribute"));
                };
                if attribute_value_name != "AttributeValue" {
                    return Err(de::Error::custom(format!(
                        "expected AttributeValue in attribute, found {attribute_value_name}"
                    )));
                }
                match attribute_name_value.as_str() {
                    "Unique Identifier" => {
                        let value: String = map.next_value()?;
                        Ok(Attribute::UniqueIdentifier(value))
                    }
                    "Name" => {
                        let value: Vec<Name> = map.next_value()?;
                        Ok(Attribute::Name(value))
                    }
                    "Object Type" => {
                        let value: ObjectType = map.next_value()?;
                        Ok(Attribute::ObjectType(value))
                    }
                    "Cryptographic Algorithm" => {
                        let value: CryptographicAlgorithm = map.next_value()?;
                        Ok(Attribute::CryptographicAlgorithm(value))
                    }
                    "Cryptographic Length" => {
                        let value: i32 = map.next_value()?;
                        Ok(Attribute::CryptographicLength(value))
                    }
                    "Cryptographic Parameters" => {
                        let value: CryptographicParameters = map.next_value()?;
                        Ok(Attribute::CryptographicParameters(value))
                    }
                    "Cryptographic Domain Parameters" => {
                        let value: CryptographicDomainParameters = map.next_value()?;
                        Ok(Attribute::CryptographicDomainParameters(value))
                    }
                    "Certificate Type" => {
                        let value: CertificateType = map.next_value()?;
                        Ok(Attribute::CertificateType(value))
                    }
                    "Certificate Length" => {
                        let value: i32 = map.next_value()?;
                        Ok(Attribute::CertificateLength(value))
                    }
                    "X.509 Certificate Identifier" => {
                        let value: X509CertificateIdentifier = map.next_value()?;
                        Ok(Attribute::X509CertificateIdentifier(value))
                    }
                    "X.509 Certificate Subject" => {
                        let value: String = map.next_value()?;
                        Ok(Attribute::X509CertificateSubject(value))
                    }
                    "X.509 Certificate Issuer" => {
                        let value: String = map.next_value()?;
                        Ok(Attribute::X509CertificateIssuer(value))
                    }
                    "Certificate Identifier" => {
                        let value: String = map.next_value()?;
                        Ok(Attribute::CertificateIdentifier(value))
                    }
                    "Certificate Subject" => {
                        let value: String = map.next_value()?;
                        Ok(Attribute::CertificateSubject(value))
                    }
                    "Certificate Issuer" => {
                        let value: String = map.next_value()?;
                        Ok(Attribute::CertificateIssuer(value))
                    }
                    "Digital Signature Algorithm" => {
                        let value: DigitalSignatureAlgorithm = map.next_value()?;
                        Ok(Attribute::DigitalSignatureAlgorithm(value))
                    }
                    "Digest" => {
                        let value: Digest = map.next_value()?;
                        Ok(Attribute::Digest(value))
                    }
                    "Operation Policy Name" => {
                        let value: String = map.next_value()?;
                        Ok(Attribute::OperationPolicyName(value))
                    }
                    "Cryptographic Usage Mask" => {
                        let value: CryptographicUsageMask = map.next_value()?;
                        Ok(Attribute::CryptographicUsageMask(value))
                    }
                    "Lease Time" => {
                        let value: i64 = map.next_value()?;
                        Ok(Attribute::LeaseTime(value))
                    }
                    "Usage Limits" => {
                        let value: UsageLimits = map.next_value()?;
                        Ok(Attribute::UsageLimits(value))
                    }
                    "State" => {
                        let value: State = map.next_value()?;
                        Ok(Attribute::State(value))
                    }
                    "Initial Date" => {
                        let value: i64 = map.next_value()?;
                        Ok(Attribute::InitialDate(value))
                    }
                    "Activation Date" => {
                        let value: i64 = map.next_value()?;
                        Ok(Attribute::ActivationDate(value))
                    }
                    "Process Start Date" => {
                        let value: i64 = map.next_value()?;
                        Ok(Attribute::ProcessStartDate(value))
                    }
                    "Protect Stop Date" => {
                        let value: i64 = map.next_value()?;
                        Ok(Attribute::ProtectStopDate(value))
                    }
                    "Deactivation Date" => {
                        let value: i64 = map.next_value()?;
                        Ok(Attribute::DeactivationDate(value))
                    }
                    "Destroy Date" => {
                        let value: i64 = map.next_value()?;
                        Ok(Attribute::DestroyDate(value))
                    }
                    "Compromise Occurrence Date" => {
                        let value: i64 = map.next_value()?;
                        Ok(Attribute::CompromiseOccurrenceDate(value))
                    }
                    "Compromise Date" => {
                        let value: i64 = map.next_value()?;
                        Ok(Attribute::CompromiseDate(value))
                    }
                    "Revocation Reason" => {
                        let value: RevocationReason = map.next_value()?;
                        Ok(Attribute::RevocationReason(value))
                    }
                    "Archive Date" => {
                        let value: i64 = map.next_value()?;
                        Ok(Attribute::ArchiveDate(value))
                    }
                    "Object Group" => {
                        let value: String = map.next_value()?;
                        Ok(Attribute::ObjectGroup(value))
                    }
                    "Fresh" => {
                        let value: bool = map.next_value()?;
                        Ok(Attribute::Fresh(value))
                    }
                    "Link" => {
                        let value: Vec<Link> = map.next_value()?;
                        Ok(Attribute::Link(value))
                    }
                    "Application Specific Information" => {
                        let value: ApplicationSpecificInformation = map.next_value()?;
                        Ok(Attribute::ApplicationSpecificInformation(value))
                    }
                    "Contact Information" => {
                        let value: String = map.next_value()?;
                        Ok(Attribute::ContactInformation(value))
                    }
                    "Last Change Date" => {
                        let value: i64 = map.next_value()?;
                        Ok(Attribute::LastChangeDate(value))
                    }
                    "Custom Attribute" => {
                        let value: CustomAttributeValue = map.next_value()?;
                        Ok(Attribute::CustomAttribute(value))
                    }
                    "Alternative Name" => {
                        let value: AlternativeName = map.next_value()?;
                        Ok(Attribute::AlternativeName(value))
                    }
                    "Key Value Present" => {
                        let value: bool = map.next_value()?;
                        Ok(Attribute::KeyValuePresent(value))
                    }
                    "Key Value Location" => {
                        let value: KeyValueLocationType = map.next_value()?;
                        Ok(Attribute::KeyValueLocation(value))
                    }
                    "Original Creation Date" => {
                        let value: i64 = map.next_value()?;
                        Ok(Attribute::OriginalCreationDate(value))
                    }
                    "Random Number Generator" => {
                        let value: RandomNumberGenerator = map.next_value()?;
                        Ok(Attribute::RandomNumberGenerator(value))
                    }
                    "PKCS#12 Friendly Name" => {
                        let value: String = map.next_value()?;
                        Ok(Attribute::Pkcs12FriendlyName(value))
                    }
                    "Description" => {
                        let value: String = map.next_value()?;
                        Ok(Attribute::Description(value))
                    }
                    "Comment" => {
                        let value: String = map.next_value()?;
                        Ok(Attribute::Comment(value))
                    }
                    "Sensitive" => {
                        let value: bool = map.next_value()?;
                        Ok(Attribute::Sensitive(value))
                    }
                    "Always Sensitive" => {
                        let value: bool = map.next_value()?;
                        Ok(Attribute::AlwaysSensitive(value))
                    }
                    "Extractable" => {
                        let value: bool = map.next_value()?;
                        Ok(Attribute::Extractable(value))
                    }
                    "Never Extractable" => {
                        let value: bool = map.next_value()?;
                        Ok(Attribute::NeverExtractable(value))
                    }
                    _ => Err(de::Error::custom(format!(
                        "invalid attribute name: {attribute_name_value}"
                    ))),
                }
            }
        }

        deserializer.deserialize_struct(
            "Attribute",
            &["AttributeName", "AttributeValue"],
            AttributeVisitor,
        )
    }
}

/// The value of a Custom Attribute (section 3.39).
/// Any data type or structure.
/// If a structure, then the structure SHALL NOT include sub structures
#[derive(Debug, Serialize, Deserialize, Clone, Eq, PartialEq)]
#[serde(untagged)]
pub enum CustomAttributeValue {
    TextString(String),
    Integer(i32),
    LongInteger(i64),
    BigInteger(Vec<u8>),
    Enumeration(u32),
    Boolean(bool),
    DateTime(i64),
    Interval(u64),
    Structure(VendorAttribute),
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::kmip_1_4::kmip_types::NameType;

    #[test]
    fn test_attributes_to_attributes() {
        // Create an Attributes instance with all fields populated
        let attrs = Attributes {
            unique_identifier: Some("id123".to_owned()),
            name: Some(vec![Name {
                name_value: "test".to_owned(),
                name_type: NameType::UninterpretedTextString,
            }]),
            // ...all other fields populated with Some values...
            never_extractable: Some(false),
            ..Default::default()
        };

        // Convert to Vec<Attribute>
        let attribute_vec = attrs.to_attributes();

        // Verify all fields are converted
        assert!(
            attribute_vec
                .iter()
                .any(|a| matches!(a, Attribute::UniqueIdentifier(_)))
        );
        assert!(
            attribute_vec
                .iter()
                .any(|a| matches!(a, Attribute::Name(_)))
        );
        // ... add assertions for all other fields ...
        assert!(
            attribute_vec
                .iter()
                .any(|a| matches!(a, Attribute::NeverExtractable(_)))
        );

        // Test with all None values
        let empty_attrs = Attributes::default();
        assert!(empty_attrs.to_attributes().is_empty());
    }
}
